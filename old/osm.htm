<!DOCTYPE html>
<html>
<head>
<meta charset="utf8">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
<script src="https://unpkg.com/leaflet-center-cross@0.0.8/dist/leaflet.CenterCross.js"></script>
<script src="https://unpkg.com/flatgeobuf/dist/flatgeobuf-geojson.min.js"></script>
<script src="./muni.js"></script>
</head>
<body>

<div id="main" style="height:800px;">
  <div id="map" style="height:800px;"></div>
  <div>
    <button onclick="zoomto_random()">random</button>
    <button onclick="zoomto_random2()">random2</button>
    <button onclick="load_japan_shape()">load japan</button>
    <span id="hoge">■</span>
    <button onclick="create_area()">create area</button>
    <input type="range" min="1" max="350" id="area_radius" oninput="change_radius()">
    <span id="area_radius_value"></span>
    <button onclick="zoomto_area_random()">area random</button>

  </div>
</div>

<script>
const def_ll = [35.164828,136.867676];
const map = L.map("map").setView(def_ll,5);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
}).addTo(map);

const centercross = L.control.centerCross({
    show: true,
    position: "topleft"
});
map.addControl(centercross);

const marker = L.marker(def_ll);
let f_marker = false;
let popup = null;

let f_show_area = false;
const elm_area_radius = document.querySelector("#area_radius");
const elm_area_radius_value = document.querySelector("#area_radius_value");
let area_radius = 50;
elm_area_radius.value = area_radius;
elm_area_radius_value.innerText = area_radius + " km";
function change_radius(){
  area_radius = parseInt(elm_area_radius.value);
  elm_area_radius_value.innerText = area_radius + " km";
  if(f_show_area) area.setRadius(area_radius*1000);
}
const area = L.circle(def_ll, {radius:area_radius*1000});
function create_area(){
  if(!f_show_area){
    area.setLatLng(map.getCenter());
    area.addTo(map);    
    f_show_area = true;
  }
  else{
    area.remove();
    f_show_area = false;
  }
  
}

function area_random(ll, radius){
  const angle = Math.random() * 2 * Math.PI; //radian
  const dist = Math.random() * radius; //km
  const lat_rad = ll[0] * Math.PI / 180; //radian
  const lng_rad = ll[1] * Math.PI / 180; //radian

  const a = 6378.137;
  const f = 1 / 298.257222101;
  const e2 = 2*f - f*f;
  const W = Math.sqrt(1 - e2 * Math.pow(Math.sin(lat_rad),2));
  const M = a * (1 - e2) / Math.pow(W,3)
  const N = a / W;

  const dlat = dist * Math.cos(angle) / M; //radian
  const dlng = dist * Math.sin(angle) / (N * Math.cos(lat_rad)); //radian
  
  const lat2 = (lat_rad + dlat) * 180 / Math.PI;
  const lng2 = (lng_rad + dlng) * 180 / Math.PI;

  return [lat2, lng2]

}

function zoomto_area_random(){
  const ll = area.getLatLng();
  const latlng = area_random([ll.lat, ll.lng], area_radius);
  put_marker(latlng);
}

function zoomto_random(){
  const latlng = japan_random();
  put_marker(latlng);
}

function japan_random(){
  const ranges = [
    [20.419291, 45.548679],
    [122.931519, 153.995361]
  ];
  return ranges.map(r=>{
    const rr = [Math.min(...r),Math.max(...r)];
    return rr[0] + Math.random()*(rr[1]-rr[0]);
  });
}
function zoomto_random2(){
  if(!japan_features.length){
    return;
  }
  let point;
  let count=0;
  console.time("y");
  while(true){
    count++;
    const latlng = japan_random();
    if(check_japan_hit(latlng)){
      point = latlng;
      break;
    }
  }
  console.timeEnd("y");
  console.log("y", count);
  put_marker(point);
}

function put_marker(latlng, nopopup){
  if(popup){popup.closePopup();}
  if(!f_marker){
   marker.addTo(map);
   f_marker = true;
  }
  marker.setLatLng(latlng);
  map.flyTo(latlng, 10, {animate:true});  
  if(nopopup) return;
  fetch(`https://mreversegeocoder.gsi.go.jp/reverse-geocoder/LonLatToAddress?lat=${latlng[0]}&lon=${latlng[1]}`)
    .then(resp=>resp.json())
    .then(json=>{
      if(!json.results){
        console.log("not japan");
        return;
      }
      console.log(json.results);
      const townName = json.results.lv01Nm;
      const muniCd = json.results.muniCd;
      const muni = Muni.get(muniCd);
      if(!muni){ console.log("unknown place"); return; }
      const prefName = muni.prefName;
      const muniName = muni.muniName;
      /*if(!f_popup){
        popup.addTo(map);
        f_popup = true;
      }*/
      setTimeout(()=>{
        popup = marker.bindPopup(`${prefName}${muniName}${townName=="-"?"":townName}<br />に、行ってらっしゃい`).openPopup()
      },1000);
      //console.log(`${prefName}${muniName}${townName=="-"?"":townName}に、行ってらっしゃい`)

    });

}
const japan = {
  name:"日本",
  filename:"japan_simple5b.fgb",
  urlbase:"./",
  range:[
    [20.419291, 45.548679],
    [122.931519, 153.995361]
  ],
  loaded:false,
  features:[],
  meta:{}
}

const japan_features = [];
async function load_japan_shape(){
  const url="./japan_simple5b.fgb";
  fetch(url).then(async resp=>{
    for await (let feature of flatgeobuf.deserialize(resp.body, undefined, (meta)=>console.log("meta", meta))){
      console.log("feature loaded", feature);
      const defaultStyle = { 
        color: 'blue', 
        weight: 2, 
        fillOpacity: 0.2,
      };
      japan_features.push(feature);
      L.geoJSON(feature, {
        style:defaultStyle
      }).addTo(map);
    }
    console.log("load end");
    map.on("click", e=>{
      console.time("x");
      const f =  check_japan_hit(latlng)
      console.timeEnd("x");
      document.querySelector("#hoge").style.color=f?"#00f":"#f00";
    })
  })
}
function check_japan_hit(latlng){
  return japan_features.some(feature=>geo_pointPolygonIntersection(latlng,feature))
}


function pointPolygonIntersection(point, polygon){
  //https://www.nttpc.co.jp/technology/number_algorithm.html
  let count = 0;
  const len = polygon.length;
  for (let i=0; i < len-1; i++){
    const pol0 = polygon[i], pol1 = polygon[i+1];
    if( ((pol0[1] <= point[1]) && (pol1[1] > point[1])) || ((pol0[1] > point[1]) && (pol1[1] <= point[1])) ){
      const vt = (point[1] - pol0[1]) / (pol1[1] - pol0[1]);
      if (point[0] < (pol0[0] + (vt * (pol1[0] - pol0[0])))){
        count++;
      }
    }
  }
  return !!(count % 2);
}


function geo_pointPolygonIntersection(point, feature){
  point = [point[1],point[0]];
  const geometry = feature.geometry;
  const polygons = [];
  if(!geometry || !geometry.coordinates) return false;
  //console.log("type",geometry.type, geometry.coordinates);
  if(geometry.type=="MultiPolygon" || geometry.type=="Polygon"){
    polygons.push(...geometry.coordinates);
  }
  else{
    return false;
  }
  //console.log(coordinates, point);
  loop: for (let j=0; j < polygons.length; j++){
    const polygon = polygons[j];
    if(pointPolygonIntersection(point, polygon[0])){
      for(let i=1; i < polygon.length; i++){
        if(pointPolygonIntersection(point, polygon[i])){
          continue loop;
        }
      }
      return true;
    }
  }
  return false;
}

const prefecture_list = {
  "鳥取県":{
    name:"鳥取県",
    filename:"tottori.fgb"
  }
};
let f_pref_list_loaded = false;
async function load_prefecture_list(){
  if(f_pref_list_loaded) return;
  await fetch("./pref/list.json").then(resp=>resp.json()).then(json=>{
    for(let prefName in json){
      prefecture_list[prefName] = json[prefName];
      prefecture_list[prefName].loaded = false;
      prefecture_list[prefName].features = [];
      prefecture_list[prefName].urlbase = "./pref/";
      prefecture_list[prefName].meta = {};
    }
    f_pref_list_loaded = true;
  })
  /*fetch("./pref/list.txt").then(resp=>resp.text()).then(text=>{
    text.split("\n").map(row=>{
      const cells = row.split("\t")
      const prefName = cells[0];
      const filename = cells[1];
      prefecture_list[prefName] = {name:prefName, filename:filename};
    });
    f_pref_list_loaded = true;
  });*/
}

async function load_pref(prefName){
  if(!f_pref_list_loaded){
    await load_prefecture_list();
  }
  const pref = prefecture_list[prefName];
  if(!pref) return;
  load_region(pref);
}

async function load_region(region){
  if(region.loaded) return region.features;
  const url= region.urlbase + region.filename;
  const features = [];
  fetch(url).then(async resp=>{
    for await (let feature of flatgeobuf.deserialize(resp.body, undefined, meta=>{region.meta=meta})){
      features.push(feature);
    }
    region.features = features;
    region.loaded = true;
    return features;
  })
}
async function region_random(region){
  await load_region(region);
  const random_point = range=>range.map(r=>{
    const rr = [Math.min(...r),Math.max(...r)];
    return rr[0] + Math.random()*(rr[1]-rr[0]);
  });
  const range = region.range;
  let point;
  let count=0;
  console.time("y");
  while(true){
    count++;
    const latlng = random_point(range);
    if(check_region_hit(latlng, region)){
      point = latlng;
      break;
    }
  }
  console.timeEnd("y");
  console.log("y", count);
  put_marker(point);
}

function check_region_hit(latlng, region){
  return region.features.some(feature=>geo_pointPolygonIntersection(latlng,feature))
}


async function calc_pref_range(){
  if(!f_pref_list_loaded) return;
  const ps = [];
  for (let prefName in prefecture_list){
    console.log(prefName);
    const url = "./pref/"+prefecture_list[prefName].filename;
    const p = fetch(url).then(async resp=>{
      let min_lat = 46, max_lat = 20;
      let min_lng = 154, max_lng = 122;
      for await (let feature of flatgeobuf.deserialize(resp.body, undefined, (meta)=>console.log(prefName, "meta", meta))){
        //console.log(feature);
        const geometry = feature.geometry;
        const polygons = [];        
        if(geometry.type=="MultiPolygon" || geometry.type=="Polygon"){
          polygons.push(...geometry.coordinates);
        }
        else{
          return false;
        }        
        //console.log(polygons);
        for (let j=0; j < polygons.length; j++){
          const polygon = polygons[j];
          
          for (let i=0; i < polygon.length; i++){
            const lat = polygon[i][1];
            const lng = polygon[i][0];
            //if(i==0)console.log(lat,lng);
            if(lat < min_lat) min_lat = lat;
            if(lat > max_lat) max_lat = lat;
            if(lng < min_lng) min_lng = lng;
            if(lng > max_lng) max_lng = lng;
          }
        }
      }
      console.log(min_lat, max_lat, min_lng, max_lng);
      prefecture_list[prefName].filename = prefecture_list[prefName].filename.replace(/\r/g,"");
      prefecture_list[prefName].range = [[min_lat, max_lat],[min_lng, max_lng]];
      prefecture_list[prefName].code = prefCodeDic.get(prefName);
    });
    ps.push(p);
  }
  Promise.all(ps).then(()=>{
    const text = JSON.stringify(prefecture_list);
    const blob = new Blob([text], {type:"application/json"});
    const objecturl = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = objecturl;
    link.download = "list.json";
    document.body.appendChild(link);
    link.click();
  })
}

</script>
</body>
</html>